/// @author Mykola Konyk <mykola@konyk.org>
///
/// @copyright 2015
/// @license MS-RL
/// This file is autogenerated from util/hapi_structuers_nif.c.template

#include "hapi_private_nif.h"
#include "hapi_enums_nif.h"
#include "hapi_types_nif.h"
#include "hapi_structures_nif.h"
#include <string.h>


/* Converting HAPI_CookOptions from c to erl. */
ERL_NIF_TERM
hapi_make_hapi_cook_options(ErlNifEnv* env, const HAPI_CookOptions* hapi_struct)
{
    return enif_make_tuple(env, 7,
        hapi_make_atom(env, "hapi_cook_options"),
        hapi_make_hapi_bool(env, hapi_struct->splitGeosByGroup),
        hapi_make_int(env, hapi_struct->maxVerticesPerPrimitive),
        hapi_make_hapi_bool(env, hapi_struct->refineCurveToLinear),
        hapi_make_float(env, hapi_struct->curveRefineLOD),
        hapi_make_hapi_bool(env, hapi_struct->clearErrorsAndWarnings),
        hapi_make_hapi_bool(env, hapi_struct->cookTemplatedGeos));
}


/* Converting HAPI_CookOptions from erl to c. */
bool
hapi_get_hapi_cook_options(ErlNifEnv* env, const ERL_NIF_TERM term, HAPI_CookOptions* hapi_struct)
{
    int32_t tuple_size = 0;
    const ERL_NIF_TERM* tuple_record = NULL;
    bool atom_name_match = false;

    HAPI_Bool field_split_geos_by_group;
    int field_max_vertices_per_primitive;
    HAPI_Bool field_refine_curve_to_linear;
    float field_curve_refine_lod;
    HAPI_Bool field_clear_errors_and_warnings;
    HAPI_Bool field_cook_templated_geos;

    if(!enif_get_tuple(env, term, &tuple_size, &tuple_record) ||
        (tuple_size != 7) ||
        !hapi_check_atom(env, tuple_record[0], "hapi_cook_options", &atom_name_match) ||
        !atom_name_match ||
        !hapi_get_hapi_bool(env, tuple_record[1], &field_split_geos_by_group)||
        !hapi_get_int(env, tuple_record[2], &field_max_vertices_per_primitive)||
        !hapi_get_hapi_bool(env, tuple_record[3], &field_refine_curve_to_linear)||
        !hapi_get_float(env, tuple_record[4], &field_curve_refine_lod)||
        !hapi_get_hapi_bool(env, tuple_record[5], &field_clear_errors_and_warnings)||
        !hapi_get_hapi_bool(env, tuple_record[6], &field_cook_templated_geos))
    {
        return false;
    }

    hapi_struct->splitGeosByGroup = field_split_geos_by_group;
    hapi_struct->maxVerticesPerPrimitive = field_max_vertices_per_primitive;
    hapi_struct->refineCurveToLinear = field_refine_curve_to_linear;
    hapi_struct->curveRefineLOD = field_curve_refine_lod;
    hapi_struct->clearErrorsAndWarnings = field_clear_errors_and_warnings;
    hapi_struct->cookTemplatedGeos = field_cook_templated_geos;

    return true;
}


/* Converting array of HAPI_CookOptions objects from c to erl. */
ERL_NIF_TERM
hapi_make_hapi_cook_options_list(ErlNifEnv* env, const HAPI_CookOptions* hapi_structs, uint32_t list_size)
{
    ERL_NIF_TERM list = enif_make_list(env, 0);

    for(int32_t idx = list_size - 1; idx >= 0; idx--)
    {
        const HAPI_CookOptions* hapi_struct = hapi_structs + idx;
        list = enif_make_list_cell(env, hapi_make_hapi_cook_options(env, hapi_struct), list);
    }

    return list;
}


/* Converting list of HAPI_CookOptions objects from erl to c. */
bool
hapi_get_hapi_cook_options_list(ErlNifEnv* env, const ERL_NIF_TERM term, HAPI_CookOptions* hapi_structs, uint32_t list_size)
{
    uint32_t read_list_size = 0;
    ERL_NIF_TERM head, tail;

    if(enif_get_list_length(env, term, &read_list_size) && (list_size == read_list_size))
    {
        ERL_NIF_TERM list = term;
        int32_t index = 0;

        while(enif_get_list_cell(env, list, &head, &tail))
        {
            HAPI_CookOptions* hapi_struct = hapi_structs + index;

            if(!hapi_get_hapi_cook_options(env, head, hapi_struct))
            {
                return false;
            }

            index++;
            list = tail;
        }

        return true;
    }

    return false;
}

/* Converting HAPI_Keyframe from c to erl. */
ERL_NIF_TERM
hapi_make_hapi_keyframe(ErlNifEnv* env, const HAPI_Keyframe* hapi_struct)
{
    return enif_make_tuple(env, 5,
        hapi_make_atom(env, "hapi_keyframe"),
        hapi_make_float(env, hapi_struct->time),
        hapi_make_float(env, hapi_struct->value),
        hapi_make_float(env, hapi_struct->inTangent),
        hapi_make_float(env, hapi_struct->outTangent));
}


/* Converting HAPI_Keyframe from erl to c. */
bool
hapi_get_hapi_keyframe(ErlNifEnv* env, const ERL_NIF_TERM term, HAPI_Keyframe* hapi_struct)
{
    int32_t tuple_size = 0;
    const ERL_NIF_TERM* tuple_record = NULL;
    bool atom_name_match = false;

    float field_time;
    float field_value;
    float field_in_tangent;
    float field_out_tangent;

    if(!enif_get_tuple(env, term, &tuple_size, &tuple_record) ||
        (tuple_size != 5) ||
        !hapi_check_atom(env, tuple_record[0], "hapi_keyframe", &atom_name_match) ||
        !atom_name_match ||
        !hapi_get_float(env, tuple_record[1], &field_time)||
        !hapi_get_float(env, tuple_record[2], &field_value)||
        !hapi_get_float(env, tuple_record[3], &field_in_tangent)||
        !hapi_get_float(env, tuple_record[4], &field_out_tangent))
    {
        return false;
    }

    hapi_struct->time = field_time;
    hapi_struct->value = field_value;
    hapi_struct->inTangent = field_in_tangent;
    hapi_struct->outTangent = field_out_tangent;

    return true;
}


/* Converting array of HAPI_Keyframe objects from c to erl. */
ERL_NIF_TERM
hapi_make_hapi_keyframe_list(ErlNifEnv* env, const HAPI_Keyframe* hapi_structs, uint32_t list_size)
{
    ERL_NIF_TERM list = enif_make_list(env, 0);

    for(int32_t idx = list_size - 1; idx >= 0; idx--)
    {
        const HAPI_Keyframe* hapi_struct = hapi_structs + idx;
        list = enif_make_list_cell(env, hapi_make_hapi_keyframe(env, hapi_struct), list);
    }

    return list;
}


/* Converting list of HAPI_Keyframe objects from erl to c. */
bool
hapi_get_hapi_keyframe_list(ErlNifEnv* env, const ERL_NIF_TERM term, HAPI_Keyframe* hapi_structs, uint32_t list_size)
{
    uint32_t read_list_size = 0;
    ERL_NIF_TERM head, tail;

    if(enif_get_list_length(env, term, &read_list_size) && (list_size == read_list_size))
    {
        ERL_NIF_TERM list = term;
        int32_t index = 0;

        while(enif_get_list_cell(env, list, &head, &tail))
        {
            HAPI_Keyframe* hapi_struct = hapi_structs + index;

            if(!hapi_get_hapi_keyframe(env, head, hapi_struct))
            {
                return false;
            }

            index++;
            list = tail;
        }

        return true;
    }

    return false;
}

/* Converting HAPI_PartInfo from c to erl. */
ERL_NIF_TERM
hapi_make_hapi_part_info(ErlNifEnv* env, const HAPI_PartInfo* hapi_struct)
{
    return enif_make_tuple(env, 12,
        hapi_make_atom(env, "hapi_part_info"),
        hapi_make_hapi_part_id(env, hapi_struct->id),
        hapi_make_hapi_string_handle(env, hapi_struct->nameSH),
        hapi_make_int(env, hapi_struct->faceCount),
        hapi_make_int(env, hapi_struct->vertexCount),
        hapi_make_int(env, hapi_struct->pointCount),
        hapi_make_int(env, hapi_struct->pointAttributeCount),
        hapi_make_int(env, hapi_struct->faceAttributeCount),
        hapi_make_int(env, hapi_struct->vertexAttributeCount),
        hapi_make_int(env, hapi_struct->detailAttributeCount),
        hapi_make_hapi_bool(env, hapi_struct->hasVolume),
        hapi_make_hapi_bool(env, hapi_struct->isCurve));
}


/* Converting HAPI_PartInfo from erl to c. */
bool
hapi_get_hapi_part_info(ErlNifEnv* env, const ERL_NIF_TERM term, HAPI_PartInfo* hapi_struct)
{
    int32_t tuple_size = 0;
    const ERL_NIF_TERM* tuple_record = NULL;
    bool atom_name_match = false;

    HAPI_PartId field_id;
    HAPI_StringHandle field_name_sh;
    int field_face_count;
    int field_vertex_count;
    int field_point_count;
    int field_point_attribute_count;
    int field_face_attribute_count;
    int field_vertex_attribute_count;
    int field_detail_attribute_count;
    HAPI_Bool field_has_volume;
    HAPI_Bool field_is_curve;

    if(!enif_get_tuple(env, term, &tuple_size, &tuple_record) ||
        (tuple_size != 12) ||
        !hapi_check_atom(env, tuple_record[0], "hapi_part_info", &atom_name_match) ||
        !atom_name_match ||
        !hapi_get_hapi_part_id(env, tuple_record[1], &field_id)||
        !hapi_get_hapi_string_handle(env, tuple_record[2], &field_name_sh)||
        !hapi_get_int(env, tuple_record[3], &field_face_count)||
        !hapi_get_int(env, tuple_record[4], &field_vertex_count)||
        !hapi_get_int(env, tuple_record[5], &field_point_count)||
        !hapi_get_int(env, tuple_record[6], &field_point_attribute_count)||
        !hapi_get_int(env, tuple_record[7], &field_face_attribute_count)||
        !hapi_get_int(env, tuple_record[8], &field_vertex_attribute_count)||
        !hapi_get_int(env, tuple_record[9], &field_detail_attribute_count)||
        !hapi_get_hapi_bool(env, tuple_record[10], &field_has_volume)||
        !hapi_get_hapi_bool(env, tuple_record[11], &field_is_curve))
    {
        return false;
    }

    hapi_struct->id = field_id;
    hapi_struct->nameSH = field_name_sh;
    hapi_struct->faceCount = field_face_count;
    hapi_struct->vertexCount = field_vertex_count;
    hapi_struct->pointCount = field_point_count;
    hapi_struct->pointAttributeCount = field_point_attribute_count;
    hapi_struct->faceAttributeCount = field_face_attribute_count;
    hapi_struct->vertexAttributeCount = field_vertex_attribute_count;
    hapi_struct->detailAttributeCount = field_detail_attribute_count;
    hapi_struct->hasVolume = field_has_volume;
    hapi_struct->isCurve = field_is_curve;

    return true;
}


/* Converting array of HAPI_PartInfo objects from c to erl. */
ERL_NIF_TERM
hapi_make_hapi_part_info_list(ErlNifEnv* env, const HAPI_PartInfo* hapi_structs, uint32_t list_size)
{
    ERL_NIF_TERM list = enif_make_list(env, 0);

    for(int32_t idx = list_size - 1; idx >= 0; idx--)
    {
        const HAPI_PartInfo* hapi_struct = hapi_structs + idx;
        list = enif_make_list_cell(env, hapi_make_hapi_part_info(env, hapi_struct), list);
    }

    return list;
}


/* Converting list of HAPI_PartInfo objects from erl to c. */
bool
hapi_get_hapi_part_info_list(ErlNifEnv* env, const ERL_NIF_TERM term, HAPI_PartInfo* hapi_structs, uint32_t list_size)
{
    uint32_t read_list_size = 0;
    ERL_NIF_TERM head, tail;

    if(enif_get_list_length(env, term, &read_list_size) && (list_size == read_list_size))
    {
        ERL_NIF_TERM list = term;
        int32_t index = 0;

        while(enif_get_list_cell(env, list, &head, &tail))
        {
            HAPI_PartInfo* hapi_struct = hapi_structs + index;

            if(!hapi_get_hapi_part_info(env, head, hapi_struct))
            {
                return false;
            }

            index++;
            list = tail;
        }

        return true;
    }

    return false;
}

/* Converting HAPI_MaterialInfo from c to erl. */
ERL_NIF_TERM
hapi_make_hapi_material_info(ErlNifEnv* env, const HAPI_MaterialInfo* hapi_struct)
{
    return enif_make_tuple(env, 6,
        hapi_make_atom(env, "hapi_material_info"),
        hapi_make_hapi_material_id(env, hapi_struct->id),
        hapi_make_hapi_asset_id(env, hapi_struct->assetId),
        hapi_make_hapi_node_id(env, hapi_struct->nodeId),
        hapi_make_hapi_bool(env, hapi_struct->exists),
        hapi_make_hapi_bool(env, hapi_struct->hasChanged));
}


/* Converting HAPI_MaterialInfo from erl to c. */
bool
hapi_get_hapi_material_info(ErlNifEnv* env, const ERL_NIF_TERM term, HAPI_MaterialInfo* hapi_struct)
{
    int32_t tuple_size = 0;
    const ERL_NIF_TERM* tuple_record = NULL;
    bool atom_name_match = false;

    HAPI_MaterialId field_id;
    HAPI_AssetId field_asset_id;
    HAPI_NodeId field_node_id;
    HAPI_Bool field_exists;
    HAPI_Bool field_has_changed;

    if(!enif_get_tuple(env, term, &tuple_size, &tuple_record) ||
        (tuple_size != 6) ||
        !hapi_check_atom(env, tuple_record[0], "hapi_material_info", &atom_name_match) ||
        !atom_name_match ||
        !hapi_get_hapi_material_id(env, tuple_record[1], &field_id)||
        !hapi_get_hapi_asset_id(env, tuple_record[2], &field_asset_id)||
        !hapi_get_hapi_node_id(env, tuple_record[3], &field_node_id)||
        !hapi_get_hapi_bool(env, tuple_record[4], &field_exists)||
        !hapi_get_hapi_bool(env, tuple_record[5], &field_has_changed))
    {
        return false;
    }

    hapi_struct->id = field_id;
    hapi_struct->assetId = field_asset_id;
    hapi_struct->nodeId = field_node_id;
    hapi_struct->exists = field_exists;
    hapi_struct->hasChanged = field_has_changed;

    return true;
}


/* Converting array of HAPI_MaterialInfo objects from c to erl. */
ERL_NIF_TERM
hapi_make_hapi_material_info_list(ErlNifEnv* env, const HAPI_MaterialInfo* hapi_structs, uint32_t list_size)
{
    ERL_NIF_TERM list = enif_make_list(env, 0);

    for(int32_t idx = list_size - 1; idx >= 0; idx--)
    {
        const HAPI_MaterialInfo* hapi_struct = hapi_structs + idx;
        list = enif_make_list_cell(env, hapi_make_hapi_material_info(env, hapi_struct), list);
    }

    return list;
}


/* Converting list of HAPI_MaterialInfo objects from erl to c. */
bool
hapi_get_hapi_material_info_list(ErlNifEnv* env, const ERL_NIF_TERM term, HAPI_MaterialInfo* hapi_structs, uint32_t list_size)
{
    uint32_t read_list_size = 0;
    ERL_NIF_TERM head, tail;

    if(enif_get_list_length(env, term, &read_list_size) && (list_size == read_list_size))
    {
        ERL_NIF_TERM list = term;
        int32_t index = 0;

        while(enif_get_list_cell(env, list, &head, &tail))
        {
            HAPI_MaterialInfo* hapi_struct = hapi_structs + index;

            if(!hapi_get_hapi_material_info(env, head, hapi_struct))
            {
                return false;
            }

            index++;
            list = tail;
        }

        return true;
    }

    return false;
}

/* Converting HAPI_GlobalNodes from c to erl. */
ERL_NIF_TERM
hapi_make_hapi_global_nodes(ErlNifEnv* env, const HAPI_GlobalNodes* hapi_struct)
{
    return enif_make_tuple(env, 4,
        hapi_make_atom(env, "hapi_global_nodes"),
        hapi_make_hapi_node_id(env, hapi_struct->defaultCamera),
        hapi_make_hapi_node_id(env, hapi_struct->defaultLight),
        hapi_make_hapi_node_id(env, hapi_struct->mantraRenderer));
}


/* Converting HAPI_GlobalNodes from erl to c. */
bool
hapi_get_hapi_global_nodes(ErlNifEnv* env, const ERL_NIF_TERM term, HAPI_GlobalNodes* hapi_struct)
{
    int32_t tuple_size = 0;
    const ERL_NIF_TERM* tuple_record = NULL;
    bool atom_name_match = false;

    HAPI_NodeId field_default_camera;
    HAPI_NodeId field_default_light;
    HAPI_NodeId field_mantra_renderer;

    if(!enif_get_tuple(env, term, &tuple_size, &tuple_record) ||
        (tuple_size != 4) ||
        !hapi_check_atom(env, tuple_record[0], "hapi_global_nodes", &atom_name_match) ||
        !atom_name_match ||
        !hapi_get_hapi_node_id(env, tuple_record[1], &field_default_camera)||
        !hapi_get_hapi_node_id(env, tuple_record[2], &field_default_light)||
        !hapi_get_hapi_node_id(env, tuple_record[3], &field_mantra_renderer))
    {
        return false;
    }

    hapi_struct->defaultCamera = field_default_camera;
    hapi_struct->defaultLight = field_default_light;
    hapi_struct->mantraRenderer = field_mantra_renderer;

    return true;
}


/* Converting array of HAPI_GlobalNodes objects from c to erl. */
ERL_NIF_TERM
hapi_make_hapi_global_nodes_list(ErlNifEnv* env, const HAPI_GlobalNodes* hapi_structs, uint32_t list_size)
{
    ERL_NIF_TERM list = enif_make_list(env, 0);

    for(int32_t idx = list_size - 1; idx >= 0; idx--)
    {
        const HAPI_GlobalNodes* hapi_struct = hapi_structs + idx;
        list = enif_make_list_cell(env, hapi_make_hapi_global_nodes(env, hapi_struct), list);
    }

    return list;
}


/* Converting list of HAPI_GlobalNodes objects from erl to c. */
bool
hapi_get_hapi_global_nodes_list(ErlNifEnv* env, const ERL_NIF_TERM term, HAPI_GlobalNodes* hapi_structs, uint32_t list_size)
{
    uint32_t read_list_size = 0;
    ERL_NIF_TERM head, tail;

    if(enif_get_list_length(env, term, &read_list_size) && (list_size == read_list_size))
    {
        ERL_NIF_TERM list = term;
        int32_t index = 0;

        while(enif_get_list_cell(env, list, &head, &tail))
        {
            HAPI_GlobalNodes* hapi_struct = hapi_structs + index;

            if(!hapi_get_hapi_global_nodes(env, head, hapi_struct))
            {
                return false;
            }

            index++;
            list = tail;
        }

        return true;
    }

    return false;
}

/* Converting HAPI_HandleBindingInfo from c to erl. */
ERL_NIF_TERM
hapi_make_hapi_handle_binding_info(ErlNifEnv* env, const HAPI_HandleBindingInfo* hapi_struct)
{
    return enif_make_tuple(env, 4,
        hapi_make_atom(env, "hapi_handle_binding_info"),
        hapi_make_hapi_string_handle(env, hapi_struct->handleParmNameSH),
        hapi_make_hapi_string_handle(env, hapi_struct->assetParmNameSH),
        hapi_make_hapi_parm_id(env, hapi_struct->assetParmId));
}


/* Converting HAPI_HandleBindingInfo from erl to c. */
bool
hapi_get_hapi_handle_binding_info(ErlNifEnv* env, const ERL_NIF_TERM term, HAPI_HandleBindingInfo* hapi_struct)
{
    int32_t tuple_size = 0;
    const ERL_NIF_TERM* tuple_record = NULL;
    bool atom_name_match = false;

    HAPI_StringHandle field_handle_parm_name_sh;
    HAPI_StringHandle field_asset_parm_name_sh;
    HAPI_ParmId field_asset_parm_id;

    if(!enif_get_tuple(env, term, &tuple_size, &tuple_record) ||
        (tuple_size != 4) ||
        !hapi_check_atom(env, tuple_record[0], "hapi_handle_binding_info", &atom_name_match) ||
        !atom_name_match ||
        !hapi_get_hapi_string_handle(env, tuple_record[1], &field_handle_parm_name_sh)||
        !hapi_get_hapi_string_handle(env, tuple_record[2], &field_asset_parm_name_sh)||
        !hapi_get_hapi_parm_id(env, tuple_record[3], &field_asset_parm_id))
    {
        return false;
    }

    hapi_struct->handleParmNameSH = field_handle_parm_name_sh;
    hapi_struct->assetParmNameSH = field_asset_parm_name_sh;
    hapi_struct->assetParmId = field_asset_parm_id;

    return true;
}


/* Converting array of HAPI_HandleBindingInfo objects from c to erl. */
ERL_NIF_TERM
hapi_make_hapi_handle_binding_info_list(ErlNifEnv* env, const HAPI_HandleBindingInfo* hapi_structs, uint32_t list_size)
{
    ERL_NIF_TERM list = enif_make_list(env, 0);

    for(int32_t idx = list_size - 1; idx >= 0; idx--)
    {
        const HAPI_HandleBindingInfo* hapi_struct = hapi_structs + idx;
        list = enif_make_list_cell(env, hapi_make_hapi_handle_binding_info(env, hapi_struct), list);
    }

    return list;
}


/* Converting list of HAPI_HandleBindingInfo objects from erl to c. */
bool
hapi_get_hapi_handle_binding_info_list(ErlNifEnv* env, const ERL_NIF_TERM term, HAPI_HandleBindingInfo* hapi_structs, uint32_t list_size)
{
    uint32_t read_list_size = 0;
    ERL_NIF_TERM head, tail;

    if(enif_get_list_length(env, term, &read_list_size) && (list_size == read_list_size))
    {
        ERL_NIF_TERM list = term;
        int32_t index = 0;

        while(enif_get_list_cell(env, list, &head, &tail))
        {
            HAPI_HandleBindingInfo* hapi_struct = hapi_structs + index;

            if(!hapi_get_hapi_handle_binding_info(env, head, hapi_struct))
            {
                return false;
            }

            index++;
            list = tail;
        }

        return true;
    }

    return false;
}

/* Converting HAPI_ImageInfo from c to erl. */
ERL_NIF_TERM
hapi_make_hapi_image_info(ErlNifEnv* env, const HAPI_ImageInfo* hapi_struct)
{
    return enif_make_tuple(env, 8,
        hapi_make_atom(env, "hapi_image_info"),
        hapi_make_hapi_string_handle(env, hapi_struct->imageFileFormatNameSH),
        hapi_make_int(env, hapi_struct->xRes),
        hapi_make_int(env, hapi_struct->yRes),
        hapi_make_hapi_image_data_format(env, hapi_struct->dataFormat),
        hapi_make_hapi_bool(env, hapi_struct->interleaved),
        hapi_make_hapi_image_packing(env, hapi_struct->packing),
        hapi_make_double(env, hapi_struct->gamma));
}


/* Converting HAPI_ImageInfo from erl to c. */
bool
hapi_get_hapi_image_info(ErlNifEnv* env, const ERL_NIF_TERM term, HAPI_ImageInfo* hapi_struct)
{
    int32_t tuple_size = 0;
    const ERL_NIF_TERM* tuple_record = NULL;
    bool atom_name_match = false;

    HAPI_StringHandle field_image_file_format_name_sh;
    int field_x_res;
    int field_y_res;
    HAPI_ImageDataFormat field_data_format;
    HAPI_Bool field_interleaved;
    HAPI_ImagePacking field_packing;
    double field_gamma;

    if(!enif_get_tuple(env, term, &tuple_size, &tuple_record) ||
        (tuple_size != 8) ||
        !hapi_check_atom(env, tuple_record[0], "hapi_image_info", &atom_name_match) ||
        !atom_name_match ||
        !hapi_get_hapi_string_handle(env, tuple_record[1], &field_image_file_format_name_sh)||
        !hapi_get_int(env, tuple_record[2], &field_x_res)||
        !hapi_get_int(env, tuple_record[3], &field_y_res)||
        !hapi_get_hapi_image_data_format(env, tuple_record[4], &field_data_format)||
        !hapi_get_hapi_bool(env, tuple_record[5], &field_interleaved)||
        !hapi_get_hapi_image_packing(env, tuple_record[6], &field_packing)||
        !hapi_get_double(env, tuple_record[7], &field_gamma))
    {
        return false;
    }

    hapi_struct->imageFileFormatNameSH = field_image_file_format_name_sh;
    hapi_struct->xRes = field_x_res;
    hapi_struct->yRes = field_y_res;
    hapi_struct->dataFormat = field_data_format;
    hapi_struct->interleaved = field_interleaved;
    hapi_struct->packing = field_packing;
    hapi_struct->gamma = field_gamma;

    return true;
}


/* Converting array of HAPI_ImageInfo objects from c to erl. */
ERL_NIF_TERM
hapi_make_hapi_image_info_list(ErlNifEnv* env, const HAPI_ImageInfo* hapi_structs, uint32_t list_size)
{
    ERL_NIF_TERM list = enif_make_list(env, 0);

    for(int32_t idx = list_size - 1; idx >= 0; idx--)
    {
        const HAPI_ImageInfo* hapi_struct = hapi_structs + idx;
        list = enif_make_list_cell(env, hapi_make_hapi_image_info(env, hapi_struct), list);
    }

    return list;
}


/* Converting list of HAPI_ImageInfo objects from erl to c. */
bool
hapi_get_hapi_image_info_list(ErlNifEnv* env, const ERL_NIF_TERM term, HAPI_ImageInfo* hapi_structs, uint32_t list_size)
{
    uint32_t read_list_size = 0;
    ERL_NIF_TERM head, tail;

    if(enif_get_list_length(env, term, &read_list_size) && (list_size == read_list_size))
    {
        ERL_NIF_TERM list = term;
        int32_t index = 0;

        while(enif_get_list_cell(env, list, &head, &tail))
        {
            HAPI_ImageInfo* hapi_struct = hapi_structs + index;

            if(!hapi_get_hapi_image_info(env, head, hapi_struct))
            {
                return false;
            }

            index++;
            list = tail;
        }

        return true;
    }

    return false;
}

/* Converting HAPI_VolumeInfo from c to erl. */
ERL_NIF_TERM
hapi_make_hapi_volume_info(ErlNifEnv* env, const HAPI_VolumeInfo* hapi_struct)
{
    return enif_make_tuple(env, 15,
        hapi_make_atom(env, "hapi_volume_info"),
        hapi_make_hapi_string_handle(env, hapi_struct->nameSH),
        hapi_make_int(env, hapi_struct->xLength),
        hapi_make_int(env, hapi_struct->yLength),
        hapi_make_int(env, hapi_struct->zLength),
        hapi_make_int(env, hapi_struct->minX),
        hapi_make_int(env, hapi_struct->minY),
        hapi_make_int(env, hapi_struct->minZ),
        hapi_make_int(env, hapi_struct->tupleSize),
        hapi_make_hapi_storage_type(env, hapi_struct->storage),
        hapi_make_int(env, hapi_struct->tileSize),
        hapi_make_hapi_transform(env, &hapi_struct->transform),
        hapi_make_hapi_bool(env, hapi_struct->hasTaper),
        hapi_make_float(env, hapi_struct->xTaper),
        hapi_make_float(env, hapi_struct->yTaper));
}


/* Converting HAPI_VolumeInfo from erl to c. */
bool
hapi_get_hapi_volume_info(ErlNifEnv* env, const ERL_NIF_TERM term, HAPI_VolumeInfo* hapi_struct)
{
    int32_t tuple_size = 0;
    const ERL_NIF_TERM* tuple_record = NULL;
    bool atom_name_match = false;

    HAPI_StringHandle field_name_sh;
    int field_x_length;
    int field_y_length;
    int field_z_length;
    int field_min_x;
    int field_min_y;
    int field_min_z;
    int field_tuple_size;
    HAPI_StorageType field_storage;
    int field_tile_size;
    HAPI_Transform field_transform;
    HAPI_Bool field_has_taper;
    float field_x_taper;
    float field_y_taper;

    if(!enif_get_tuple(env, term, &tuple_size, &tuple_record) ||
        (tuple_size != 15) ||
        !hapi_check_atom(env, tuple_record[0], "hapi_volume_info", &atom_name_match) ||
        !atom_name_match ||
        !hapi_get_hapi_string_handle(env, tuple_record[1], &field_name_sh)||
        !hapi_get_int(env, tuple_record[2], &field_x_length)||
        !hapi_get_int(env, tuple_record[3], &field_y_length)||
        !hapi_get_int(env, tuple_record[4], &field_z_length)||
        !hapi_get_int(env, tuple_record[5], &field_min_x)||
        !hapi_get_int(env, tuple_record[6], &field_min_y)||
        !hapi_get_int(env, tuple_record[7], &field_min_z)||
        !hapi_get_int(env, tuple_record[8], &field_tuple_size)||
        !hapi_get_hapi_storage_type(env, tuple_record[9], &field_storage)||
        !hapi_get_int(env, tuple_record[10], &field_tile_size)||
        !hapi_get_hapi_transform(env, tuple_record[11], &field_transform)||
        !hapi_get_hapi_bool(env, tuple_record[12], &field_has_taper)||
        !hapi_get_float(env, tuple_record[13], &field_x_taper)||
        !hapi_get_float(env, tuple_record[14], &field_y_taper))
    {
        return false;
    }

    hapi_struct->nameSH = field_name_sh;
    hapi_struct->xLength = field_x_length;
    hapi_struct->yLength = field_y_length;
    hapi_struct->zLength = field_z_length;
    hapi_struct->minX = field_min_x;
    hapi_struct->minY = field_min_y;
    hapi_struct->minZ = field_min_z;
    hapi_struct->tupleSize = field_tuple_size;
    hapi_struct->storage = field_storage;
    hapi_struct->tileSize = field_tile_size;
    memcpy(&hapi_struct->transform, &field_transform, sizeof(HAPI_Transform));
    hapi_struct->hasTaper = field_has_taper;
    hapi_struct->xTaper = field_x_taper;
    hapi_struct->yTaper = field_y_taper;

    return true;
}


/* Converting array of HAPI_VolumeInfo objects from c to erl. */
ERL_NIF_TERM
hapi_make_hapi_volume_info_list(ErlNifEnv* env, const HAPI_VolumeInfo* hapi_structs, uint32_t list_size)
{
    ERL_NIF_TERM list = enif_make_list(env, 0);

    for(int32_t idx = list_size - 1; idx >= 0; idx--)
    {
        const HAPI_VolumeInfo* hapi_struct = hapi_structs + idx;
        list = enif_make_list_cell(env, hapi_make_hapi_volume_info(env, hapi_struct), list);
    }

    return list;
}


/* Converting list of HAPI_VolumeInfo objects from erl to c. */
bool
hapi_get_hapi_volume_info_list(ErlNifEnv* env, const ERL_NIF_TERM term, HAPI_VolumeInfo* hapi_structs, uint32_t list_size)
{
    uint32_t read_list_size = 0;
    ERL_NIF_TERM head, tail;

    if(enif_get_list_length(env, term, &read_list_size) && (list_size == read_list_size))
    {
        ERL_NIF_TERM list = term;
        int32_t index = 0;

        while(enif_get_list_cell(env, list, &head, &tail))
        {
            HAPI_VolumeInfo* hapi_struct = hapi_structs + index;

            if(!hapi_get_hapi_volume_info(env, head, hapi_struct))
            {
                return false;
            }

            index++;
            list = tail;
        }

        return true;
    }

    return false;
}

/* Converting HAPI_GeoInputInfo from c to erl. */
ERL_NIF_TERM
hapi_make_hapi_geo_input_info(ErlNifEnv* env, const HAPI_GeoInputInfo* hapi_struct)
{
    return enif_make_tuple(env, 4,
        hapi_make_atom(env, "hapi_geo_input_info"),
        hapi_make_hapi_object_id(env, hapi_struct->objectId),
        hapi_make_hapi_geo_id(env, hapi_struct->geoId),
        hapi_make_hapi_node_id(env, hapi_struct->objectNodeId));
}


/* Converting HAPI_GeoInputInfo from erl to c. */
bool
hapi_get_hapi_geo_input_info(ErlNifEnv* env, const ERL_NIF_TERM term, HAPI_GeoInputInfo* hapi_struct)
{
    int32_t tuple_size = 0;
    const ERL_NIF_TERM* tuple_record = NULL;
    bool atom_name_match = false;

    HAPI_ObjectId field_object_id;
    HAPI_GeoId field_geo_id;
    HAPI_NodeId field_object_node_id;

    if(!enif_get_tuple(env, term, &tuple_size, &tuple_record) ||
        (tuple_size != 4) ||
        !hapi_check_atom(env, tuple_record[0], "hapi_geo_input_info", &atom_name_match) ||
        !atom_name_match ||
        !hapi_get_hapi_object_id(env, tuple_record[1], &field_object_id)||
        !hapi_get_hapi_geo_id(env, tuple_record[2], &field_geo_id)||
        !hapi_get_hapi_node_id(env, tuple_record[3], &field_object_node_id))
    {
        return false;
    }

    hapi_struct->objectId = field_object_id;
    hapi_struct->geoId = field_geo_id;
    hapi_struct->objectNodeId = field_object_node_id;

    return true;
}


/* Converting array of HAPI_GeoInputInfo objects from c to erl. */
ERL_NIF_TERM
hapi_make_hapi_geo_input_info_list(ErlNifEnv* env, const HAPI_GeoInputInfo* hapi_structs, uint32_t list_size)
{
    ERL_NIF_TERM list = enif_make_list(env, 0);

    for(int32_t idx = list_size - 1; idx >= 0; idx--)
    {
        const HAPI_GeoInputInfo* hapi_struct = hapi_structs + idx;
        list = enif_make_list_cell(env, hapi_make_hapi_geo_input_info(env, hapi_struct), list);
    }

    return list;
}


/* Converting list of HAPI_GeoInputInfo objects from erl to c. */
bool
hapi_get_hapi_geo_input_info_list(ErlNifEnv* env, const ERL_NIF_TERM term, HAPI_GeoInputInfo* hapi_structs, uint32_t list_size)
{
    uint32_t read_list_size = 0;
    ERL_NIF_TERM head, tail;

    if(enif_get_list_length(env, term, &read_list_size) && (list_size == read_list_size))
    {
        ERL_NIF_TERM list = term;
        int32_t index = 0;

        while(enif_get_list_cell(env, list, &head, &tail))
        {
            HAPI_GeoInputInfo* hapi_struct = hapi_structs + index;

            if(!hapi_get_hapi_geo_input_info(env, head, hapi_struct))
            {
                return false;
            }

            index++;
            list = tail;
        }

        return true;
    }

    return false;
}

/* Converting HAPI_VolumeTileInfo from c to erl. */
ERL_NIF_TERM
hapi_make_hapi_volume_tile_info(ErlNifEnv* env, const HAPI_VolumeTileInfo* hapi_struct)
{
    return enif_make_tuple(env, 5,
        hapi_make_atom(env, "hapi_volume_tile_info"),
        hapi_make_int(env, hapi_struct->minX),
        hapi_make_int(env, hapi_struct->minY),
        hapi_make_int(env, hapi_struct->minZ),
        hapi_make_hapi_bool(env, hapi_struct->isValid));
}


/* Converting HAPI_VolumeTileInfo from erl to c. */
bool
hapi_get_hapi_volume_tile_info(ErlNifEnv* env, const ERL_NIF_TERM term, HAPI_VolumeTileInfo* hapi_struct)
{
    int32_t tuple_size = 0;
    const ERL_NIF_TERM* tuple_record = NULL;
    bool atom_name_match = false;

    int field_min_x;
    int field_min_y;
    int field_min_z;
    HAPI_Bool field_is_valid;

    if(!enif_get_tuple(env, term, &tuple_size, &tuple_record) ||
        (tuple_size != 5) ||
        !hapi_check_atom(env, tuple_record[0], "hapi_volume_tile_info", &atom_name_match) ||
        !atom_name_match ||
        !hapi_get_int(env, tuple_record[1], &field_min_x)||
        !hapi_get_int(env, tuple_record[2], &field_min_y)||
        !hapi_get_int(env, tuple_record[3], &field_min_z)||
        !hapi_get_hapi_bool(env, tuple_record[4], &field_is_valid))
    {
        return false;
    }

    hapi_struct->minX = field_min_x;
    hapi_struct->minY = field_min_y;
    hapi_struct->minZ = field_min_z;
    hapi_struct->isValid = field_is_valid;

    return true;
}


/* Converting array of HAPI_VolumeTileInfo objects from c to erl. */
ERL_NIF_TERM
hapi_make_hapi_volume_tile_info_list(ErlNifEnv* env, const HAPI_VolumeTileInfo* hapi_structs, uint32_t list_size)
{
    ERL_NIF_TERM list = enif_make_list(env, 0);

    for(int32_t idx = list_size - 1; idx >= 0; idx--)
    {
        const HAPI_VolumeTileInfo* hapi_struct = hapi_structs + idx;
        list = enif_make_list_cell(env, hapi_make_hapi_volume_tile_info(env, hapi_struct), list);
    }

    return list;
}


/* Converting list of HAPI_VolumeTileInfo objects from erl to c. */
bool
hapi_get_hapi_volume_tile_info_list(ErlNifEnv* env, const ERL_NIF_TERM term, HAPI_VolumeTileInfo* hapi_structs, uint32_t list_size)
{
    uint32_t read_list_size = 0;
    ERL_NIF_TERM head, tail;

    if(enif_get_list_length(env, term, &read_list_size) && (list_size == read_list_size))
    {
        ERL_NIF_TERM list = term;
        int32_t index = 0;

        while(enif_get_list_cell(env, list, &head, &tail))
        {
            HAPI_VolumeTileInfo* hapi_struct = hapi_structs + index;

            if(!hapi_get_hapi_volume_tile_info(env, head, hapi_struct))
            {
                return false;
            }

            index++;
            list = tail;
        }

        return true;
    }

    return false;
}

/* Converting HAPI_CurveInfo from c to erl. */
ERL_NIF_TERM
hapi_make_hapi_curve_info(ErlNifEnv* env, const HAPI_CurveInfo* hapi_struct)
{
    return enif_make_tuple(env, 9,
        hapi_make_atom(env, "hapi_curve_info"),
        hapi_make_hapi_curve_type(env, hapi_struct->curveType),
        hapi_make_int(env, hapi_struct->curveCount),
        hapi_make_int(env, hapi_struct->vertexCount),
        hapi_make_int(env, hapi_struct->knotCount),
        hapi_make_hapi_bool(env, hapi_struct->isPeriodic),
        hapi_make_hapi_bool(env, hapi_struct->isRational),
        hapi_make_int(env, hapi_struct->order),
        hapi_make_hapi_bool(env, hapi_struct->hasKnots));
}


/* Converting HAPI_CurveInfo from erl to c. */
bool
hapi_get_hapi_curve_info(ErlNifEnv* env, const ERL_NIF_TERM term, HAPI_CurveInfo* hapi_struct)
{
    int32_t tuple_size = 0;
    const ERL_NIF_TERM* tuple_record = NULL;
    bool atom_name_match = false;

    HAPI_CurveType field_curve_type;
    int field_curve_count;
    int field_vertex_count;
    int field_knot_count;
    HAPI_Bool field_is_periodic;
    HAPI_Bool field_is_rational;
    int field_order;
    HAPI_Bool field_has_knots;

    if(!enif_get_tuple(env, term, &tuple_size, &tuple_record) ||
        (tuple_size != 9) ||
        !hapi_check_atom(env, tuple_record[0], "hapi_curve_info", &atom_name_match) ||
        !atom_name_match ||
        !hapi_get_hapi_curve_type(env, tuple_record[1], &field_curve_type)||
        !hapi_get_int(env, tuple_record[2], &field_curve_count)||
        !hapi_get_int(env, tuple_record[3], &field_vertex_count)||
        !hapi_get_int(env, tuple_record[4], &field_knot_count)||
        !hapi_get_hapi_bool(env, tuple_record[5], &field_is_periodic)||
        !hapi_get_hapi_bool(env, tuple_record[6], &field_is_rational)||
        !hapi_get_int(env, tuple_record[7], &field_order)||
        !hapi_get_hapi_bool(env, tuple_record[8], &field_has_knots))
    {
        return false;
    }

    hapi_struct->curveType = field_curve_type;
    hapi_struct->curveCount = field_curve_count;
    hapi_struct->vertexCount = field_vertex_count;
    hapi_struct->knotCount = field_knot_count;
    hapi_struct->isPeriodic = field_is_periodic;
    hapi_struct->isRational = field_is_rational;
    hapi_struct->order = field_order;
    hapi_struct->hasKnots = field_has_knots;

    return true;
}


/* Converting array of HAPI_CurveInfo objects from c to erl. */
ERL_NIF_TERM
hapi_make_hapi_curve_info_list(ErlNifEnv* env, const HAPI_CurveInfo* hapi_structs, uint32_t list_size)
{
    ERL_NIF_TERM list = enif_make_list(env, 0);

    for(int32_t idx = list_size - 1; idx >= 0; idx--)
    {
        const HAPI_CurveInfo* hapi_struct = hapi_structs + idx;
        list = enif_make_list_cell(env, hapi_make_hapi_curve_info(env, hapi_struct), list);
    }

    return list;
}


/* Converting list of HAPI_CurveInfo objects from erl to c. */
bool
hapi_get_hapi_curve_info_list(ErlNifEnv* env, const ERL_NIF_TERM term, HAPI_CurveInfo* hapi_structs, uint32_t list_size)
{
    uint32_t read_list_size = 0;
    ERL_NIF_TERM head, tail;

    if(enif_get_list_length(env, term, &read_list_size) && (list_size == read_list_size))
    {
        ERL_NIF_TERM list = term;
        int32_t index = 0;

        while(enif_get_list_cell(env, list, &head, &tail))
        {
            HAPI_CurveInfo* hapi_struct = hapi_structs + index;

            if(!hapi_get_hapi_curve_info(env, head, hapi_struct))
            {
                return false;
            }

            index++;
            list = tail;
        }

        return true;
    }

    return false;
}

/* Converting HAPI_Transform from c to erl. */
ERL_NIF_TERM
hapi_make_hapi_transform(ErlNifEnv* env, const HAPI_Transform* hapi_struct)
{
    return enif_make_tuple(env, 5,
        hapi_make_atom(env, "hapi_transform"),
        hapi_make_float_list(env, &hapi_struct->position[0], 3),
        hapi_make_float_list(env, &hapi_struct->rotationQuaternion[0], 4),
        hapi_make_float_list(env, &hapi_struct->scale[0], 3),
        hapi_make_hapi_rstorder(env, hapi_struct->rstOrder));
}


/* Converting HAPI_Transform from erl to c. */
bool
hapi_get_hapi_transform(ErlNifEnv* env, const ERL_NIF_TERM term, HAPI_Transform* hapi_struct)
{
    int32_t tuple_size = 0;
    const ERL_NIF_TERM* tuple_record = NULL;
    bool atom_name_match = false;

    float field_position[3];
    float field_rotation_quaternion[4];
    float field_scale[3];
    HAPI_RSTOrder field_rst_order;

    if(!enif_get_tuple(env, term, &tuple_size, &tuple_record) ||
        (tuple_size != 5) ||
        !hapi_check_atom(env, tuple_record[0], "hapi_transform", &atom_name_match) ||
        !atom_name_match ||
        hapi_get_float_list(env, tuple_record[1], &hapi_struct->position[0], 3)||
        hapi_get_float_list(env, tuple_record[2], &hapi_struct->rotationQuaternion[0], 4)||
        hapi_get_float_list(env, tuple_record[3], &hapi_struct->scale[0], 3)||
        !hapi_get_hapi_rstorder(env, tuple_record[4], &field_rst_order))
    {
        return false;
    }

    memcpy(&hapi_struct->position[0], &field_position[0], 3 * sizeof(float));
    memcpy(&hapi_struct->rotationQuaternion[0], &field_rotation_quaternion[0], 4 * sizeof(float));
    memcpy(&hapi_struct->scale[0], &field_scale[0], 3 * sizeof(float));
    hapi_struct->rstOrder = field_rst_order;

    return true;
}


/* Converting array of HAPI_Transform objects from c to erl. */
ERL_NIF_TERM
hapi_make_hapi_transform_list(ErlNifEnv* env, const HAPI_Transform* hapi_structs, uint32_t list_size)
{
    ERL_NIF_TERM list = enif_make_list(env, 0);

    for(int32_t idx = list_size - 1; idx >= 0; idx--)
    {
        const HAPI_Transform* hapi_struct = hapi_structs + idx;
        list = enif_make_list_cell(env, hapi_make_hapi_transform(env, hapi_struct), list);
    }

    return list;
}


/* Converting list of HAPI_Transform objects from erl to c. */
bool
hapi_get_hapi_transform_list(ErlNifEnv* env, const ERL_NIF_TERM term, HAPI_Transform* hapi_structs, uint32_t list_size)
{
    uint32_t read_list_size = 0;
    ERL_NIF_TERM head, tail;

    if(enif_get_list_length(env, term, &read_list_size) && (list_size == read_list_size))
    {
        ERL_NIF_TERM list = term;
        int32_t index = 0;

        while(enif_get_list_cell(env, list, &head, &tail))
        {
            HAPI_Transform* hapi_struct = hapi_structs + index;

            if(!hapi_get_hapi_transform(env, head, hapi_struct))
            {
                return false;
            }

            index++;
            list = tail;
        }

        return true;
    }

    return false;
}

/* Converting HAPI_ImageFileFormat from c to erl. */
ERL_NIF_TERM
hapi_make_hapi_image_file_format(ErlNifEnv* env, const HAPI_ImageFileFormat* hapi_struct)
{
    return enif_make_tuple(env, 4,
        hapi_make_atom(env, "hapi_image_file_format"),
        hapi_make_hapi_string_handle(env, hapi_struct->nameSH),
        hapi_make_hapi_string_handle(env, hapi_struct->descriptionSH),
        hapi_make_hapi_string_handle(env, hapi_struct->defaultExtensionSH));
}


/* Converting HAPI_ImageFileFormat from erl to c. */
bool
hapi_get_hapi_image_file_format(ErlNifEnv* env, const ERL_NIF_TERM term, HAPI_ImageFileFormat* hapi_struct)
{
    int32_t tuple_size = 0;
    const ERL_NIF_TERM* tuple_record = NULL;
    bool atom_name_match = false;

    HAPI_StringHandle field_name_sh;
    HAPI_StringHandle field_description_sh;
    HAPI_StringHandle field_default_extension_sh;

    if(!enif_get_tuple(env, term, &tuple_size, &tuple_record) ||
        (tuple_size != 4) ||
        !hapi_check_atom(env, tuple_record[0], "hapi_image_file_format", &atom_name_match) ||
        !atom_name_match ||
        !hapi_get_hapi_string_handle(env, tuple_record[1], &field_name_sh)||
        !hapi_get_hapi_string_handle(env, tuple_record[2], &field_description_sh)||
        !hapi_get_hapi_string_handle(env, tuple_record[3], &field_default_extension_sh))
    {
        return false;
    }

    hapi_struct->nameSH = field_name_sh;
    hapi_struct->descriptionSH = field_description_sh;
    hapi_struct->defaultExtensionSH = field_default_extension_sh;

    return true;
}


/* Converting array of HAPI_ImageFileFormat objects from c to erl. */
ERL_NIF_TERM
hapi_make_hapi_image_file_format_list(ErlNifEnv* env, const HAPI_ImageFileFormat* hapi_structs, uint32_t list_size)
{
    ERL_NIF_TERM list = enif_make_list(env, 0);

    for(int32_t idx = list_size - 1; idx >= 0; idx--)
    {
        const HAPI_ImageFileFormat* hapi_struct = hapi_structs + idx;
        list = enif_make_list_cell(env, hapi_make_hapi_image_file_format(env, hapi_struct), list);
    }

    return list;
}


/* Converting list of HAPI_ImageFileFormat objects from erl to c. */
bool
hapi_get_hapi_image_file_format_list(ErlNifEnv* env, const ERL_NIF_TERM term, HAPI_ImageFileFormat* hapi_structs, uint32_t list_size)
{
    uint32_t read_list_size = 0;
    ERL_NIF_TERM head, tail;

    if(enif_get_list_length(env, term, &read_list_size) && (list_size == read_list_size))
    {
        ERL_NIF_TERM list = term;
        int32_t index = 0;

        while(enif_get_list_cell(env, list, &head, &tail))
        {
            HAPI_ImageFileFormat* hapi_struct = hapi_structs + index;

            if(!hapi_get_hapi_image_file_format(env, head, hapi_struct))
            {
                return false;
            }

            index++;
            list = tail;
        }

        return true;
    }

    return false;
}

/* Converting HAPI_TransformEuler from c to erl. */
ERL_NIF_TERM
hapi_make_hapi_transform_euler(ErlNifEnv* env, const HAPI_TransformEuler* hapi_struct)
{
    return enif_make_tuple(env, 6,
        hapi_make_atom(env, "hapi_transform_euler"),
        hapi_make_float_list(env, &hapi_struct->position[0], 3),
        hapi_make_float_list(env, &hapi_struct->rotationEuler[0], 3),
        hapi_make_float_list(env, &hapi_struct->scale[0], 3),
        hapi_make_hapi_xyzorder(env, hapi_struct->rotationOrder),
        hapi_make_hapi_rstorder(env, hapi_struct->rstOrder));
}


/* Converting HAPI_TransformEuler from erl to c. */
bool
hapi_get_hapi_transform_euler(ErlNifEnv* env, const ERL_NIF_TERM term, HAPI_TransformEuler* hapi_struct)
{
    int32_t tuple_size = 0;
    const ERL_NIF_TERM* tuple_record = NULL;
    bool atom_name_match = false;

    float field_position[3];
    float field_rotation_euler[3];
    float field_scale[3];
    HAPI_XYZOrder field_rotation_order;
    HAPI_RSTOrder field_rst_order;

    if(!enif_get_tuple(env, term, &tuple_size, &tuple_record) ||
        (tuple_size != 6) ||
        !hapi_check_atom(env, tuple_record[0], "hapi_transform_euler", &atom_name_match) ||
        !atom_name_match ||
        hapi_get_float_list(env, tuple_record[1], &hapi_struct->position[0], 3)||
        hapi_get_float_list(env, tuple_record[2], &hapi_struct->rotationEuler[0], 3)||
        hapi_get_float_list(env, tuple_record[3], &hapi_struct->scale[0], 3)||
        !hapi_get_hapi_xyzorder(env, tuple_record[4], &field_rotation_order)||
        !hapi_get_hapi_rstorder(env, tuple_record[5], &field_rst_order))
    {
        return false;
    }

    memcpy(&hapi_struct->position[0], &field_position[0], 3 * sizeof(float));
    memcpy(&hapi_struct->rotationEuler[0], &field_rotation_euler[0], 3 * sizeof(float));
    memcpy(&hapi_struct->scale[0], &field_scale[0], 3 * sizeof(float));
    hapi_struct->rotationOrder = field_rotation_order;
    hapi_struct->rstOrder = field_rst_order;

    return true;
}


/* Converting array of HAPI_TransformEuler objects from c to erl. */
ERL_NIF_TERM
hapi_make_hapi_transform_euler_list(ErlNifEnv* env, const HAPI_TransformEuler* hapi_structs, uint32_t list_size)
{
    ERL_NIF_TERM list = enif_make_list(env, 0);

    for(int32_t idx = list_size - 1; idx >= 0; idx--)
    {
        const HAPI_TransformEuler* hapi_struct = hapi_structs + idx;
        list = enif_make_list_cell(env, hapi_make_hapi_transform_euler(env, hapi_struct), list);
    }

    return list;
}


/* Converting list of HAPI_TransformEuler objects from erl to c. */
bool
hapi_get_hapi_transform_euler_list(ErlNifEnv* env, const ERL_NIF_TERM term, HAPI_TransformEuler* hapi_structs, uint32_t list_size)
{
    uint32_t read_list_size = 0;
    ERL_NIF_TERM head, tail;

    if(enif_get_list_length(env, term, &read_list_size) && (list_size == read_list_size))
    {
        ERL_NIF_TERM list = term;
        int32_t index = 0;

        while(enif_get_list_cell(env, list, &head, &tail))
        {
            HAPI_TransformEuler* hapi_struct = hapi_structs + index;

            if(!hapi_get_hapi_transform_euler(env, head, hapi_struct))
            {
                return false;
            }

            index++;
            list = tail;
        }

        return true;
    }

    return false;
}

/* Converting HAPI_AttributeInfo from c to erl. */
ERL_NIF_TERM
hapi_make_hapi_attribute_info(ErlNifEnv* env, const HAPI_AttributeInfo* hapi_struct)
{
    return enif_make_tuple(env, 7,
        hapi_make_atom(env, "hapi_attribute_info"),
        hapi_make_hapi_bool(env, hapi_struct->exists),
        hapi_make_hapi_attribute_owner(env, hapi_struct->owner),
        hapi_make_hapi_storage_type(env, hapi_struct->storage),
        hapi_make_hapi_attribute_owner(env, hapi_struct->originalOwner),
        hapi_make_int(env, hapi_struct->count),
        hapi_make_int(env, hapi_struct->tupleSize));
}


/* Converting HAPI_AttributeInfo from erl to c. */
bool
hapi_get_hapi_attribute_info(ErlNifEnv* env, const ERL_NIF_TERM term, HAPI_AttributeInfo* hapi_struct)
{
    int32_t tuple_size = 0;
    const ERL_NIF_TERM* tuple_record = NULL;
    bool atom_name_match = false;

    HAPI_Bool field_exists;
    HAPI_AttributeOwner field_owner;
    HAPI_StorageType field_storage;
    HAPI_AttributeOwner field_original_owner;
    int field_count;
    int field_tuple_size;

    if(!enif_get_tuple(env, term, &tuple_size, &tuple_record) ||
        (tuple_size != 7) ||
        !hapi_check_atom(env, tuple_record[0], "hapi_attribute_info", &atom_name_match) ||
        !atom_name_match ||
        !hapi_get_hapi_bool(env, tuple_record[1], &field_exists)||
        !hapi_get_hapi_attribute_owner(env, tuple_record[2], &field_owner)||
        !hapi_get_hapi_storage_type(env, tuple_record[3], &field_storage)||
        !hapi_get_hapi_attribute_owner(env, tuple_record[4], &field_original_owner)||
        !hapi_get_int(env, tuple_record[5], &field_count)||
        !hapi_get_int(env, tuple_record[6], &field_tuple_size))
    {
        return false;
    }

    hapi_struct->exists = field_exists;
    hapi_struct->owner = field_owner;
    hapi_struct->storage = field_storage;
    hapi_struct->originalOwner = field_original_owner;
    hapi_struct->count = field_count;
    hapi_struct->tupleSize = field_tuple_size;

    return true;
}


/* Converting array of HAPI_AttributeInfo objects from c to erl. */
ERL_NIF_TERM
hapi_make_hapi_attribute_info_list(ErlNifEnv* env, const HAPI_AttributeInfo* hapi_structs, uint32_t list_size)
{
    ERL_NIF_TERM list = enif_make_list(env, 0);

    for(int32_t idx = list_size - 1; idx >= 0; idx--)
    {
        const HAPI_AttributeInfo* hapi_struct = hapi_structs + idx;
        list = enif_make_list_cell(env, hapi_make_hapi_attribute_info(env, hapi_struct), list);
    }

    return list;
}


/* Converting list of HAPI_AttributeInfo objects from erl to c. */
bool
hapi_get_hapi_attribute_info_list(ErlNifEnv* env, const ERL_NIF_TERM term, HAPI_AttributeInfo* hapi_structs, uint32_t list_size)
{
    uint32_t read_list_size = 0;
    ERL_NIF_TERM head, tail;

    if(enif_get_list_length(env, term, &read_list_size) && (list_size == read_list_size))
    {
        ERL_NIF_TERM list = term;
        int32_t index = 0;

        while(enif_get_list_cell(env, list, &head, &tail))
        {
            HAPI_AttributeInfo* hapi_struct = hapi_structs + index;

            if(!hapi_get_hapi_attribute_info(env, head, hapi_struct))
            {
                return false;
            }

            index++;
            list = tail;
        }

        return true;
    }

    return false;
}

/* Converting HAPI_GeoInfo from c to erl. */
ERL_NIF_TERM
hapi_make_hapi_geo_info(ErlNifEnv* env, const HAPI_GeoInfo* hapi_struct)
{
    return enif_make_tuple(env, 13,
        hapi_make_atom(env, "hapi_geo_info"),
        hapi_make_hapi_geo_id(env, hapi_struct->id),
        hapi_make_hapi_geo_type(env, hapi_struct->type),
        hapi_make_hapi_string_handle(env, hapi_struct->nameSH),
        hapi_make_hapi_node_id(env, hapi_struct->nodeId),
        hapi_make_hapi_bool(env, hapi_struct->isEditable),
        hapi_make_hapi_bool(env, hapi_struct->isTemplated),
        hapi_make_hapi_bool(env, hapi_struct->isDisplayGeo),
        hapi_make_hapi_bool(env, hapi_struct->hasGeoChanged),
        hapi_make_hapi_bool(env, hapi_struct->hasMaterialChanged),
        hapi_make_int(env, hapi_struct->pointGroupCount),
        hapi_make_int(env, hapi_struct->primitiveGroupCount),
        hapi_make_int(env, hapi_struct->partCount));
}


/* Converting HAPI_GeoInfo from erl to c. */
bool
hapi_get_hapi_geo_info(ErlNifEnv* env, const ERL_NIF_TERM term, HAPI_GeoInfo* hapi_struct)
{
    int32_t tuple_size = 0;
    const ERL_NIF_TERM* tuple_record = NULL;
    bool atom_name_match = false;

    HAPI_GeoId field_id;
    HAPI_GeoType field_type;
    HAPI_StringHandle field_name_sh;
    HAPI_NodeId field_node_id;
    HAPI_Bool field_is_editable;
    HAPI_Bool field_is_templated;
    HAPI_Bool field_is_display_geo;
    HAPI_Bool field_has_geo_changed;
    HAPI_Bool field_has_material_changed;
    int field_point_group_count;
    int field_primitive_group_count;
    int field_part_count;

    if(!enif_get_tuple(env, term, &tuple_size, &tuple_record) ||
        (tuple_size != 13) ||
        !hapi_check_atom(env, tuple_record[0], "hapi_geo_info", &atom_name_match) ||
        !atom_name_match ||
        !hapi_get_hapi_geo_id(env, tuple_record[1], &field_id)||
        !hapi_get_hapi_geo_type(env, tuple_record[2], &field_type)||
        !hapi_get_hapi_string_handle(env, tuple_record[3], &field_name_sh)||
        !hapi_get_hapi_node_id(env, tuple_record[4], &field_node_id)||
        !hapi_get_hapi_bool(env, tuple_record[5], &field_is_editable)||
        !hapi_get_hapi_bool(env, tuple_record[6], &field_is_templated)||
        !hapi_get_hapi_bool(env, tuple_record[7], &field_is_display_geo)||
        !hapi_get_hapi_bool(env, tuple_record[8], &field_has_geo_changed)||
        !hapi_get_hapi_bool(env, tuple_record[9], &field_has_material_changed)||
        !hapi_get_int(env, tuple_record[10], &field_point_group_count)||
        !hapi_get_int(env, tuple_record[11], &field_primitive_group_count)||
        !hapi_get_int(env, tuple_record[12], &field_part_count))
    {
        return false;
    }

    hapi_struct->id = field_id;
    hapi_struct->type = field_type;
    hapi_struct->nameSH = field_name_sh;
    hapi_struct->nodeId = field_node_id;
    hapi_struct->isEditable = field_is_editable;
    hapi_struct->isTemplated = field_is_templated;
    hapi_struct->isDisplayGeo = field_is_display_geo;
    hapi_struct->hasGeoChanged = field_has_geo_changed;
    hapi_struct->hasMaterialChanged = field_has_material_changed;
    hapi_struct->pointGroupCount = field_point_group_count;
    hapi_struct->primitiveGroupCount = field_primitive_group_count;
    hapi_struct->partCount = field_part_count;

    return true;
}


/* Converting array of HAPI_GeoInfo objects from c to erl. */
ERL_NIF_TERM
hapi_make_hapi_geo_info_list(ErlNifEnv* env, const HAPI_GeoInfo* hapi_structs, uint32_t list_size)
{
    ERL_NIF_TERM list = enif_make_list(env, 0);

    for(int32_t idx = list_size - 1; idx >= 0; idx--)
    {
        const HAPI_GeoInfo* hapi_struct = hapi_structs + idx;
        list = enif_make_list_cell(env, hapi_make_hapi_geo_info(env, hapi_struct), list);
    }

    return list;
}


/* Converting list of HAPI_GeoInfo objects from erl to c. */
bool
hapi_get_hapi_geo_info_list(ErlNifEnv* env, const ERL_NIF_TERM term, HAPI_GeoInfo* hapi_structs, uint32_t list_size)
{
    uint32_t read_list_size = 0;
    ERL_NIF_TERM head, tail;

    if(enif_get_list_length(env, term, &read_list_size) && (list_size == read_list_size))
    {
        ERL_NIF_TERM list = term;
        int32_t index = 0;

        while(enif_get_list_cell(env, list, &head, &tail))
        {
            HAPI_GeoInfo* hapi_struct = hapi_structs + index;

            if(!hapi_get_hapi_geo_info(env, head, hapi_struct))
            {
                return false;
            }

            index++;
            list = tail;
        }

        return true;
    }

    return false;
}

/* Converting HAPI_AssetInfo from c to erl. */
ERL_NIF_TERM
hapi_make_hapi_asset_info(ErlNifEnv* env, const HAPI_AssetInfo* hapi_struct)
{
    return enif_make_tuple(env, 20,
        hapi_make_atom(env, "hapi_asset_info"),
        hapi_make_hapi_asset_id(env, hapi_struct->id),
        hapi_make_hapi_asset_type(env, hapi_struct->type),
        hapi_make_hapi_asset_sub_type(env, hapi_struct->subType),
        hapi_make_int(env, hapi_struct->validationId),
        hapi_make_hapi_node_id(env, hapi_struct->nodeId),
        hapi_make_hapi_node_id(env, hapi_struct->objectNodeId),
        hapi_make_hapi_bool(env, hapi_struct->hasEverCooked),
        hapi_make_hapi_string_handle(env, hapi_struct->nameSH),
        hapi_make_hapi_string_handle(env, hapi_struct->labelSH),
        hapi_make_hapi_string_handle(env, hapi_struct->filePathSH),
        hapi_make_hapi_string_handle(env, hapi_struct->versionSH),
        hapi_make_hapi_string_handle(env, hapi_struct->fullOpNameSH),
        hapi_make_hapi_string_handle(env, hapi_struct->helpTextSH),
        hapi_make_int(env, hapi_struct->objectCount),
        hapi_make_int(env, hapi_struct->handleCount),
        hapi_make_int(env, hapi_struct->transformInputCount),
        hapi_make_int(env, hapi_struct->geoInputCount),
        hapi_make_hapi_bool(env, hapi_struct->haveObjectsChanged),
        hapi_make_hapi_bool(env, hapi_struct->haveMaterialsChanged));
}


/* Converting HAPI_AssetInfo from erl to c. */
bool
hapi_get_hapi_asset_info(ErlNifEnv* env, const ERL_NIF_TERM term, HAPI_AssetInfo* hapi_struct)
{
    int32_t tuple_size = 0;
    const ERL_NIF_TERM* tuple_record = NULL;
    bool atom_name_match = false;

    HAPI_AssetId field_id;
    HAPI_AssetType field_type;
    HAPI_AssetSubType field_sub_type;
    int field_validation_id;
    HAPI_NodeId field_node_id;
    HAPI_NodeId field_object_node_id;
    HAPI_Bool field_has_ever_cooked;
    HAPI_StringHandle field_name_sh;
    HAPI_StringHandle field_label_sh;
    HAPI_StringHandle field_file_path_sh;
    HAPI_StringHandle field_version_sh;
    HAPI_StringHandle field_full_op_name_sh;
    HAPI_StringHandle field_help_text_sh;
    int field_object_count;
    int field_handle_count;
    int field_transform_input_count;
    int field_geo_input_count;
    HAPI_Bool field_have_objects_changed;
    HAPI_Bool field_have_materials_changed;

    if(!enif_get_tuple(env, term, &tuple_size, &tuple_record) ||
        (tuple_size != 20) ||
        !hapi_check_atom(env, tuple_record[0], "hapi_asset_info", &atom_name_match) ||
        !atom_name_match ||
        !hapi_get_hapi_asset_id(env, tuple_record[1], &field_id)||
        !hapi_get_hapi_asset_type(env, tuple_record[2], &field_type)||
        !hapi_get_hapi_asset_sub_type(env, tuple_record[3], &field_sub_type)||
        !hapi_get_int(env, tuple_record[4], &field_validation_id)||
        !hapi_get_hapi_node_id(env, tuple_record[5], &field_node_id)||
        !hapi_get_hapi_node_id(env, tuple_record[6], &field_object_node_id)||
        !hapi_get_hapi_bool(env, tuple_record[7], &field_has_ever_cooked)||
        !hapi_get_hapi_string_handle(env, tuple_record[8], &field_name_sh)||
        !hapi_get_hapi_string_handle(env, tuple_record[9], &field_label_sh)||
        !hapi_get_hapi_string_handle(env, tuple_record[10], &field_file_path_sh)||
        !hapi_get_hapi_string_handle(env, tuple_record[11], &field_version_sh)||
        !hapi_get_hapi_string_handle(env, tuple_record[12], &field_full_op_name_sh)||
        !hapi_get_hapi_string_handle(env, tuple_record[13], &field_help_text_sh)||
        !hapi_get_int(env, tuple_record[14], &field_object_count)||
        !hapi_get_int(env, tuple_record[15], &field_handle_count)||
        !hapi_get_int(env, tuple_record[16], &field_transform_input_count)||
        !hapi_get_int(env, tuple_record[17], &field_geo_input_count)||
        !hapi_get_hapi_bool(env, tuple_record[18], &field_have_objects_changed)||
        !hapi_get_hapi_bool(env, tuple_record[19], &field_have_materials_changed))
    {
        return false;
    }

    hapi_struct->id = field_id;
    hapi_struct->type = field_type;
    hapi_struct->subType = field_sub_type;
    hapi_struct->validationId = field_validation_id;
    hapi_struct->nodeId = field_node_id;
    hapi_struct->objectNodeId = field_object_node_id;
    hapi_struct->hasEverCooked = field_has_ever_cooked;
    hapi_struct->nameSH = field_name_sh;
    hapi_struct->labelSH = field_label_sh;
    hapi_struct->filePathSH = field_file_path_sh;
    hapi_struct->versionSH = field_version_sh;
    hapi_struct->fullOpNameSH = field_full_op_name_sh;
    hapi_struct->helpTextSH = field_help_text_sh;
    hapi_struct->objectCount = field_object_count;
    hapi_struct->handleCount = field_handle_count;
    hapi_struct->transformInputCount = field_transform_input_count;
    hapi_struct->geoInputCount = field_geo_input_count;
    hapi_struct->haveObjectsChanged = field_have_objects_changed;
    hapi_struct->haveMaterialsChanged = field_have_materials_changed;

    return true;
}


/* Converting array of HAPI_AssetInfo objects from c to erl. */
ERL_NIF_TERM
hapi_make_hapi_asset_info_list(ErlNifEnv* env, const HAPI_AssetInfo* hapi_structs, uint32_t list_size)
{
    ERL_NIF_TERM list = enif_make_list(env, 0);

    for(int32_t idx = list_size - 1; idx >= 0; idx--)
    {
        const HAPI_AssetInfo* hapi_struct = hapi_structs + idx;
        list = enif_make_list_cell(env, hapi_make_hapi_asset_info(env, hapi_struct), list);
    }

    return list;
}


/* Converting list of HAPI_AssetInfo objects from erl to c. */
bool
hapi_get_hapi_asset_info_list(ErlNifEnv* env, const ERL_NIF_TERM term, HAPI_AssetInfo* hapi_structs, uint32_t list_size)
{
    uint32_t read_list_size = 0;
    ERL_NIF_TERM head, tail;

    if(enif_get_list_length(env, term, &read_list_size) && (list_size == read_list_size))
    {
        ERL_NIF_TERM list = term;
        int32_t index = 0;

        while(enif_get_list_cell(env, list, &head, &tail))
        {
            HAPI_AssetInfo* hapi_struct = hapi_structs + index;

            if(!hapi_get_hapi_asset_info(env, head, hapi_struct))
            {
                return false;
            }

            index++;
            list = tail;
        }

        return true;
    }

    return false;
}

/* Converting HAPI_ParmChoiceInfo from c to erl. */
ERL_NIF_TERM
hapi_make_hapi_parm_choice_info(ErlNifEnv* env, const HAPI_ParmChoiceInfo* hapi_struct)
{
    return enif_make_tuple(env, 4,
        hapi_make_atom(env, "hapi_parm_choice_info"),
        hapi_make_hapi_parm_id(env, hapi_struct->parentParmId),
        hapi_make_hapi_string_handle(env, hapi_struct->labelSH),
        hapi_make_hapi_string_handle(env, hapi_struct->valueSH));
}


/* Converting HAPI_ParmChoiceInfo from erl to c. */
bool
hapi_get_hapi_parm_choice_info(ErlNifEnv* env, const ERL_NIF_TERM term, HAPI_ParmChoiceInfo* hapi_struct)
{
    int32_t tuple_size = 0;
    const ERL_NIF_TERM* tuple_record = NULL;
    bool atom_name_match = false;

    HAPI_ParmId field_parent_parm_id;
    HAPI_StringHandle field_label_sh;
    HAPI_StringHandle field_value_sh;

    if(!enif_get_tuple(env, term, &tuple_size, &tuple_record) ||
        (tuple_size != 4) ||
        !hapi_check_atom(env, tuple_record[0], "hapi_parm_choice_info", &atom_name_match) ||
        !atom_name_match ||
        !hapi_get_hapi_parm_id(env, tuple_record[1], &field_parent_parm_id)||
        !hapi_get_hapi_string_handle(env, tuple_record[2], &field_label_sh)||
        !hapi_get_hapi_string_handle(env, tuple_record[3], &field_value_sh))
    {
        return false;
    }

    hapi_struct->parentParmId = field_parent_parm_id;
    hapi_struct->labelSH = field_label_sh;
    hapi_struct->valueSH = field_value_sh;

    return true;
}


/* Converting array of HAPI_ParmChoiceInfo objects from c to erl. */
ERL_NIF_TERM
hapi_make_hapi_parm_choice_info_list(ErlNifEnv* env, const HAPI_ParmChoiceInfo* hapi_structs, uint32_t list_size)
{
    ERL_NIF_TERM list = enif_make_list(env, 0);

    for(int32_t idx = list_size - 1; idx >= 0; idx--)
    {
        const HAPI_ParmChoiceInfo* hapi_struct = hapi_structs + idx;
        list = enif_make_list_cell(env, hapi_make_hapi_parm_choice_info(env, hapi_struct), list);
    }

    return list;
}


/* Converting list of HAPI_ParmChoiceInfo objects from erl to c. */
bool
hapi_get_hapi_parm_choice_info_list(ErlNifEnv* env, const ERL_NIF_TERM term, HAPI_ParmChoiceInfo* hapi_structs, uint32_t list_size)
{
    uint32_t read_list_size = 0;
    ERL_NIF_TERM head, tail;

    if(enif_get_list_length(env, term, &read_list_size) && (list_size == read_list_size))
    {
        ERL_NIF_TERM list = term;
        int32_t index = 0;

        while(enif_get_list_cell(env, list, &head, &tail))
        {
            HAPI_ParmChoiceInfo* hapi_struct = hapi_structs + index;

            if(!hapi_get_hapi_parm_choice_info(env, head, hapi_struct))
            {
                return false;
            }

            index++;
            list = tail;
        }

        return true;
    }

    return false;
}

/* Converting HAPI_ObjectInfo from c to erl. */
ERL_NIF_TERM
hapi_make_hapi_object_info(ErlNifEnv* env, const HAPI_ObjectInfo* hapi_struct)
{
    return enif_make_tuple(env, 11,
        hapi_make_atom(env, "hapi_object_info"),
        hapi_make_hapi_object_id(env, hapi_struct->id),
        hapi_make_hapi_string_handle(env, hapi_struct->nameSH),
        hapi_make_hapi_string_handle(env, hapi_struct->objectInstancePathSH),
        hapi_make_hapi_bool(env, hapi_struct->hasTransformChanged),
        hapi_make_hapi_bool(env, hapi_struct->haveGeosChanged),
        hapi_make_hapi_bool(env, hapi_struct->isVisible),
        hapi_make_hapi_bool(env, hapi_struct->isInstancer),
        hapi_make_int(env, hapi_struct->geoCount),
        hapi_make_hapi_node_id(env, hapi_struct->nodeId),
        hapi_make_hapi_object_id(env, hapi_struct->objectToInstanceId));
}


/* Converting HAPI_ObjectInfo from erl to c. */
bool
hapi_get_hapi_object_info(ErlNifEnv* env, const ERL_NIF_TERM term, HAPI_ObjectInfo* hapi_struct)
{
    int32_t tuple_size = 0;
    const ERL_NIF_TERM* tuple_record = NULL;
    bool atom_name_match = false;

    HAPI_ObjectId field_id;
    HAPI_StringHandle field_name_sh;
    HAPI_StringHandle field_object_instance_path_sh;
    HAPI_Bool field_has_transform_changed;
    HAPI_Bool field_have_geos_changed;
    HAPI_Bool field_is_visible;
    HAPI_Bool field_is_instancer;
    int field_geo_count;
    HAPI_NodeId field_node_id;
    HAPI_ObjectId field_object_to_instance_id;

    if(!enif_get_tuple(env, term, &tuple_size, &tuple_record) ||
        (tuple_size != 11) ||
        !hapi_check_atom(env, tuple_record[0], "hapi_object_info", &atom_name_match) ||
        !atom_name_match ||
        !hapi_get_hapi_object_id(env, tuple_record[1], &field_id)||
        !hapi_get_hapi_string_handle(env, tuple_record[2], &field_name_sh)||
        !hapi_get_hapi_string_handle(env, tuple_record[3], &field_object_instance_path_sh)||
        !hapi_get_hapi_bool(env, tuple_record[4], &field_has_transform_changed)||
        !hapi_get_hapi_bool(env, tuple_record[5], &field_have_geos_changed)||
        !hapi_get_hapi_bool(env, tuple_record[6], &field_is_visible)||
        !hapi_get_hapi_bool(env, tuple_record[7], &field_is_instancer)||
        !hapi_get_int(env, tuple_record[8], &field_geo_count)||
        !hapi_get_hapi_node_id(env, tuple_record[9], &field_node_id)||
        !hapi_get_hapi_object_id(env, tuple_record[10], &field_object_to_instance_id))
    {
        return false;
    }

    hapi_struct->id = field_id;
    hapi_struct->nameSH = field_name_sh;
    hapi_struct->objectInstancePathSH = field_object_instance_path_sh;
    hapi_struct->hasTransformChanged = field_has_transform_changed;
    hapi_struct->haveGeosChanged = field_have_geos_changed;
    hapi_struct->isVisible = field_is_visible;
    hapi_struct->isInstancer = field_is_instancer;
    hapi_struct->geoCount = field_geo_count;
    hapi_struct->nodeId = field_node_id;
    hapi_struct->objectToInstanceId = field_object_to_instance_id;

    return true;
}


/* Converting array of HAPI_ObjectInfo objects from c to erl. */
ERL_NIF_TERM
hapi_make_hapi_object_info_list(ErlNifEnv* env, const HAPI_ObjectInfo* hapi_structs, uint32_t list_size)
{
    ERL_NIF_TERM list = enif_make_list(env, 0);

    for(int32_t idx = list_size - 1; idx >= 0; idx--)
    {
        const HAPI_ObjectInfo* hapi_struct = hapi_structs + idx;
        list = enif_make_list_cell(env, hapi_make_hapi_object_info(env, hapi_struct), list);
    }

    return list;
}


/* Converting list of HAPI_ObjectInfo objects from erl to c. */
bool
hapi_get_hapi_object_info_list(ErlNifEnv* env, const ERL_NIF_TERM term, HAPI_ObjectInfo* hapi_structs, uint32_t list_size)
{
    uint32_t read_list_size = 0;
    ERL_NIF_TERM head, tail;

    if(enif_get_list_length(env, term, &read_list_size) && (list_size == read_list_size))
    {
        ERL_NIF_TERM list = term;
        int32_t index = 0;

        while(enif_get_list_cell(env, list, &head, &tail))
        {
            HAPI_ObjectInfo* hapi_struct = hapi_structs + index;

            if(!hapi_get_hapi_object_info(env, head, hapi_struct))
            {
                return false;
            }

            index++;
            list = tail;
        }

        return true;
    }

    return false;
}

/* Converting HAPI_HandleInfo from c to erl. */
ERL_NIF_TERM
hapi_make_hapi_handle_info(ErlNifEnv* env, const HAPI_HandleInfo* hapi_struct)
{
    return enif_make_tuple(env, 4,
        hapi_make_atom(env, "hapi_handle_info"),
        hapi_make_hapi_string_handle(env, hapi_struct->nameSH),
        hapi_make_hapi_string_handle(env, hapi_struct->typeNameSH),
        hapi_make_int(env, hapi_struct->bindingsCount));
}


/* Converting HAPI_HandleInfo from erl to c. */
bool
hapi_get_hapi_handle_info(ErlNifEnv* env, const ERL_NIF_TERM term, HAPI_HandleInfo* hapi_struct)
{
    int32_t tuple_size = 0;
    const ERL_NIF_TERM* tuple_record = NULL;
    bool atom_name_match = false;

    HAPI_StringHandle field_name_sh;
    HAPI_StringHandle field_type_name_sh;
    int field_bindings_count;

    if(!enif_get_tuple(env, term, &tuple_size, &tuple_record) ||
        (tuple_size != 4) ||
        !hapi_check_atom(env, tuple_record[0], "hapi_handle_info", &atom_name_match) ||
        !atom_name_match ||
        !hapi_get_hapi_string_handle(env, tuple_record[1], &field_name_sh)||
        !hapi_get_hapi_string_handle(env, tuple_record[2], &field_type_name_sh)||
        !hapi_get_int(env, tuple_record[3], &field_bindings_count))
    {
        return false;
    }

    hapi_struct->nameSH = field_name_sh;
    hapi_struct->typeNameSH = field_type_name_sh;
    hapi_struct->bindingsCount = field_bindings_count;

    return true;
}


/* Converting array of HAPI_HandleInfo objects from c to erl. */
ERL_NIF_TERM
hapi_make_hapi_handle_info_list(ErlNifEnv* env, const HAPI_HandleInfo* hapi_structs, uint32_t list_size)
{
    ERL_NIF_TERM list = enif_make_list(env, 0);

    for(int32_t idx = list_size - 1; idx >= 0; idx--)
    {
        const HAPI_HandleInfo* hapi_struct = hapi_structs + idx;
        list = enif_make_list_cell(env, hapi_make_hapi_handle_info(env, hapi_struct), list);
    }

    return list;
}


/* Converting list of HAPI_HandleInfo objects from erl to c. */
bool
hapi_get_hapi_handle_info_list(ErlNifEnv* env, const ERL_NIF_TERM term, HAPI_HandleInfo* hapi_structs, uint32_t list_size)
{
    uint32_t read_list_size = 0;
    ERL_NIF_TERM head, tail;

    if(enif_get_list_length(env, term, &read_list_size) && (list_size == read_list_size))
    {
        ERL_NIF_TERM list = term;
        int32_t index = 0;

        while(enif_get_list_cell(env, list, &head, &tail))
        {
            HAPI_HandleInfo* hapi_struct = hapi_structs + index;

            if(!hapi_get_hapi_handle_info(env, head, hapi_struct))
            {
                return false;
            }

            index++;
            list = tail;
        }

        return true;
    }

    return false;
}

/* Converting HAPI_TimelineOptions from c to erl. */
ERL_NIF_TERM
hapi_make_hapi_timeline_options(ErlNifEnv* env, const HAPI_TimelineOptions* hapi_struct)
{
    return enif_make_tuple(env, 4,
        hapi_make_atom(env, "hapi_timeline_options"),
        hapi_make_float(env, hapi_struct->fps),
        hapi_make_float(env, hapi_struct->startTime),
        hapi_make_float(env, hapi_struct->endTime));
}


/* Converting HAPI_TimelineOptions from erl to c. */
bool
hapi_get_hapi_timeline_options(ErlNifEnv* env, const ERL_NIF_TERM term, HAPI_TimelineOptions* hapi_struct)
{
    int32_t tuple_size = 0;
    const ERL_NIF_TERM* tuple_record = NULL;
    bool atom_name_match = false;

    float field_fps;
    float field_start_time;
    float field_end_time;

    if(!enif_get_tuple(env, term, &tuple_size, &tuple_record) ||
        (tuple_size != 4) ||
        !hapi_check_atom(env, tuple_record[0], "hapi_timeline_options", &atom_name_match) ||
        !atom_name_match ||
        !hapi_get_float(env, tuple_record[1], &field_fps)||
        !hapi_get_float(env, tuple_record[2], &field_start_time)||
        !hapi_get_float(env, tuple_record[3], &field_end_time))
    {
        return false;
    }

    hapi_struct->fps = field_fps;
    hapi_struct->startTime = field_start_time;
    hapi_struct->endTime = field_end_time;

    return true;
}


/* Converting array of HAPI_TimelineOptions objects from c to erl. */
ERL_NIF_TERM
hapi_make_hapi_timeline_options_list(ErlNifEnv* env, const HAPI_TimelineOptions* hapi_structs, uint32_t list_size)
{
    ERL_NIF_TERM list = enif_make_list(env, 0);

    for(int32_t idx = list_size - 1; idx >= 0; idx--)
    {
        const HAPI_TimelineOptions* hapi_struct = hapi_structs + idx;
        list = enif_make_list_cell(env, hapi_make_hapi_timeline_options(env, hapi_struct), list);
    }

    return list;
}


/* Converting list of HAPI_TimelineOptions objects from erl to c. */
bool
hapi_get_hapi_timeline_options_list(ErlNifEnv* env, const ERL_NIF_TERM term, HAPI_TimelineOptions* hapi_structs, uint32_t list_size)
{
    uint32_t read_list_size = 0;
    ERL_NIF_TERM head, tail;

    if(enif_get_list_length(env, term, &read_list_size) && (list_size == read_list_size))
    {
        ERL_NIF_TERM list = term;
        int32_t index = 0;

        while(enif_get_list_cell(env, list, &head, &tail))
        {
            HAPI_TimelineOptions* hapi_struct = hapi_structs + index;

            if(!hapi_get_hapi_timeline_options(env, head, hapi_struct))
            {
                return false;
            }

            index++;
            list = tail;
        }

        return true;
    }

    return false;
}

/* Converting HAPI_NodeInfo from c to erl. */
ERL_NIF_TERM
hapi_make_hapi_node_info(ErlNifEnv* env, const HAPI_NodeInfo* hapi_struct)
{
    return enif_make_tuple(env, 12,
        hapi_make_atom(env, "hapi_node_info"),
        hapi_make_hapi_node_id(env, hapi_struct->id),
        hapi_make_hapi_asset_id(env, hapi_struct->assetId),
        hapi_make_hapi_string_handle(env, hapi_struct->nameSH),
        hapi_make_int(env, hapi_struct->totalCookCount),
        hapi_make_int(env, hapi_struct->uniqueHoudiniNodeId),
        hapi_make_hapi_string_handle(env, hapi_struct->internalNodePathSH),
        hapi_make_int(env, hapi_struct->parmCount),
        hapi_make_int(env, hapi_struct->parmIntValueCount),
        hapi_make_int(env, hapi_struct->parmFloatValueCount),
        hapi_make_int(env, hapi_struct->parmStringValueCount),
        hapi_make_int(env, hapi_struct->parmChoiceCount));
}


/* Converting HAPI_NodeInfo from erl to c. */
bool
hapi_get_hapi_node_info(ErlNifEnv* env, const ERL_NIF_TERM term, HAPI_NodeInfo* hapi_struct)
{
    int32_t tuple_size = 0;
    const ERL_NIF_TERM* tuple_record = NULL;
    bool atom_name_match = false;

    HAPI_NodeId field_id;
    HAPI_AssetId field_asset_id;
    HAPI_StringHandle field_name_sh;
    int field_total_cook_count;
    int field_unique_houdini_node_id;
    HAPI_StringHandle field_internal_node_path_sh;
    int field_parm_count;
    int field_parm_int_value_count;
    int field_parm_float_value_count;
    int field_parm_string_value_count;
    int field_parm_choice_count;

    if(!enif_get_tuple(env, term, &tuple_size, &tuple_record) ||
        (tuple_size != 12) ||
        !hapi_check_atom(env, tuple_record[0], "hapi_node_info", &atom_name_match) ||
        !atom_name_match ||
        !hapi_get_hapi_node_id(env, tuple_record[1], &field_id)||
        !hapi_get_hapi_asset_id(env, tuple_record[2], &field_asset_id)||
        !hapi_get_hapi_string_handle(env, tuple_record[3], &field_name_sh)||
        !hapi_get_int(env, tuple_record[4], &field_total_cook_count)||
        !hapi_get_int(env, tuple_record[5], &field_unique_houdini_node_id)||
        !hapi_get_hapi_string_handle(env, tuple_record[6], &field_internal_node_path_sh)||
        !hapi_get_int(env, tuple_record[7], &field_parm_count)||
        !hapi_get_int(env, tuple_record[8], &field_parm_int_value_count)||
        !hapi_get_int(env, tuple_record[9], &field_parm_float_value_count)||
        !hapi_get_int(env, tuple_record[10], &field_parm_string_value_count)||
        !hapi_get_int(env, tuple_record[11], &field_parm_choice_count))
    {
        return false;
    }

    hapi_struct->id = field_id;
    hapi_struct->assetId = field_asset_id;
    hapi_struct->nameSH = field_name_sh;
    hapi_struct->totalCookCount = field_total_cook_count;
    hapi_struct->uniqueHoudiniNodeId = field_unique_houdini_node_id;
    hapi_struct->internalNodePathSH = field_internal_node_path_sh;
    hapi_struct->parmCount = field_parm_count;
    hapi_struct->parmIntValueCount = field_parm_int_value_count;
    hapi_struct->parmFloatValueCount = field_parm_float_value_count;
    hapi_struct->parmStringValueCount = field_parm_string_value_count;
    hapi_struct->parmChoiceCount = field_parm_choice_count;

    return true;
}


/* Converting array of HAPI_NodeInfo objects from c to erl. */
ERL_NIF_TERM
hapi_make_hapi_node_info_list(ErlNifEnv* env, const HAPI_NodeInfo* hapi_structs, uint32_t list_size)
{
    ERL_NIF_TERM list = enif_make_list(env, 0);

    for(int32_t idx = list_size - 1; idx >= 0; idx--)
    {
        const HAPI_NodeInfo* hapi_struct = hapi_structs + idx;
        list = enif_make_list_cell(env, hapi_make_hapi_node_info(env, hapi_struct), list);
    }

    return list;
}


/* Converting list of HAPI_NodeInfo objects from erl to c. */
bool
hapi_get_hapi_node_info_list(ErlNifEnv* env, const ERL_NIF_TERM term, HAPI_NodeInfo* hapi_structs, uint32_t list_size)
{
    uint32_t read_list_size = 0;
    ERL_NIF_TERM head, tail;

    if(enif_get_list_length(env, term, &read_list_size) && (list_size == read_list_size))
    {
        ERL_NIF_TERM list = term;
        int32_t index = 0;

        while(enif_get_list_cell(env, list, &head, &tail))
        {
            HAPI_NodeInfo* hapi_struct = hapi_structs + index;

            if(!hapi_get_hapi_node_info(env, head, hapi_struct))
            {
                return false;
            }

            index++;
            list = tail;
        }

        return true;
    }

    return false;
}

/* Converting HAPI_ParmInfo from c to erl. */
ERL_NIF_TERM
hapi_make_hapi_parm_info(ErlNifEnv* env, const HAPI_ParmInfo* hapi_struct)
{
    return enif_make_tuple(env, 35,
        hapi_make_atom(env, "hapi_parm_info"),
        hapi_make_hapi_parm_id(env, hapi_struct->id),
        hapi_make_hapi_parm_id(env, hapi_struct->parentId),
        hapi_make_hapi_parm_type(env, hapi_struct->type),
        hapi_make_hapi_string_handle(env, hapi_struct->typeInfoSH),
        hapi_make_hapi_permissions(env, hapi_struct->permissions),
        hapi_make_int(env, hapi_struct->size),
        hapi_make_int(env, hapi_struct->choiceCount),
        hapi_make_hapi_string_handle(env, hapi_struct->nameSH),
        hapi_make_hapi_string_handle(env, hapi_struct->labelSH),
        hapi_make_hapi_string_handle(env, hapi_struct->templateNameSH),
        hapi_make_hapi_string_handle(env, hapi_struct->helpSH),
        hapi_make_hapi_bool(env, hapi_struct->hasMin),
        hapi_make_hapi_bool(env, hapi_struct->hasMax),
        hapi_make_hapi_bool(env, hapi_struct->hasUIMin),
        hapi_make_hapi_bool(env, hapi_struct->hasUIMax),
        hapi_make_float(env, hapi_struct->min),
        hapi_make_float(env, hapi_struct->max),
        hapi_make_float(env, hapi_struct->UIMin),
        hapi_make_float(env, hapi_struct->UIMax),
        hapi_make_hapi_bool(env, hapi_struct->invisible),
        hapi_make_hapi_bool(env, hapi_struct->disabled),
        hapi_make_hapi_bool(env, hapi_struct->spare),
        hapi_make_hapi_bool(env, hapi_struct->joinNext),
        hapi_make_hapi_bool(env, hapi_struct->labelNone),
        hapi_make_int(env, hapi_struct->intValuesIndex),
        hapi_make_int(env, hapi_struct->floatValuesIndex),
        hapi_make_int(env, hapi_struct->stringValuesIndex),
        hapi_make_int(env, hapi_struct->choiceIndex),
        hapi_make_hapi_bool(env, hapi_struct->isChildOfMultiParm),
        hapi_make_int(env, hapi_struct->instanceNum),
        hapi_make_int(env, hapi_struct->instanceLength),
        hapi_make_int(env, hapi_struct->instanceCount),
        hapi_make_int(env, hapi_struct->instanceStartOffset),
        hapi_make_hapi_ramp_type(env, hapi_struct->rampType));
}


/* Converting HAPI_ParmInfo from erl to c. */
bool
hapi_get_hapi_parm_info(ErlNifEnv* env, const ERL_NIF_TERM term, HAPI_ParmInfo* hapi_struct)
{
    int32_t tuple_size = 0;
    const ERL_NIF_TERM* tuple_record = NULL;
    bool atom_name_match = false;

    HAPI_ParmId field_id;
    HAPI_ParmId field_parent_id;
    HAPI_ParmType field_type;
    HAPI_StringHandle field_type_info_sh;
    HAPI_Permissions field_permissions;
    int field_size;
    int field_choice_count;
    HAPI_StringHandle field_name_sh;
    HAPI_StringHandle field_label_sh;
    HAPI_StringHandle field_template_name_sh;
    HAPI_StringHandle field_help_sh;
    HAPI_Bool field_has_min;
    HAPI_Bool field_has_max;
    HAPI_Bool field_has_uimin;
    HAPI_Bool field_has_uimax;
    float field_min;
    float field_max;
    float field_uimin;
    float field_uimax;
    HAPI_Bool field_invisible;
    HAPI_Bool field_disabled;
    HAPI_Bool field_spare;
    HAPI_Bool field_join_next;
    HAPI_Bool field_label_none;
    int field_int_values_index;
    int field_float_values_index;
    int field_string_values_index;
    int field_choice_index;
    HAPI_Bool field_is_child_of_multi_parm;
    int field_instance_num;
    int field_instance_length;
    int field_instance_count;
    int field_instance_start_offset;
    HAPI_RampType field_ramp_type;

    if(!enif_get_tuple(env, term, &tuple_size, &tuple_record) ||
        (tuple_size != 35) ||
        !hapi_check_atom(env, tuple_record[0], "hapi_parm_info", &atom_name_match) ||
        !atom_name_match ||
        !hapi_get_hapi_parm_id(env, tuple_record[1], &field_id)||
        !hapi_get_hapi_parm_id(env, tuple_record[2], &field_parent_id)||
        !hapi_get_hapi_parm_type(env, tuple_record[3], &field_type)||
        !hapi_get_hapi_string_handle(env, tuple_record[4], &field_type_info_sh)||
        !hapi_get_hapi_permissions(env, tuple_record[5], &field_permissions)||
        !hapi_get_int(env, tuple_record[6], &field_size)||
        !hapi_get_int(env, tuple_record[7], &field_choice_count)||
        !hapi_get_hapi_string_handle(env, tuple_record[8], &field_name_sh)||
        !hapi_get_hapi_string_handle(env, tuple_record[9], &field_label_sh)||
        !hapi_get_hapi_string_handle(env, tuple_record[10], &field_template_name_sh)||
        !hapi_get_hapi_string_handle(env, tuple_record[11], &field_help_sh)||
        !hapi_get_hapi_bool(env, tuple_record[12], &field_has_min)||
        !hapi_get_hapi_bool(env, tuple_record[13], &field_has_max)||
        !hapi_get_hapi_bool(env, tuple_record[14], &field_has_uimin)||
        !hapi_get_hapi_bool(env, tuple_record[15], &field_has_uimax)||
        !hapi_get_float(env, tuple_record[16], &field_min)||
        !hapi_get_float(env, tuple_record[17], &field_max)||
        !hapi_get_float(env, tuple_record[18], &field_uimin)||
        !hapi_get_float(env, tuple_record[19], &field_uimax)||
        !hapi_get_hapi_bool(env, tuple_record[20], &field_invisible)||
        !hapi_get_hapi_bool(env, tuple_record[21], &field_disabled)||
        !hapi_get_hapi_bool(env, tuple_record[22], &field_spare)||
        !hapi_get_hapi_bool(env, tuple_record[23], &field_join_next)||
        !hapi_get_hapi_bool(env, tuple_record[24], &field_label_none)||
        !hapi_get_int(env, tuple_record[25], &field_int_values_index)||
        !hapi_get_int(env, tuple_record[26], &field_float_values_index)||
        !hapi_get_int(env, tuple_record[27], &field_string_values_index)||
        !hapi_get_int(env, tuple_record[28], &field_choice_index)||
        !hapi_get_hapi_bool(env, tuple_record[29], &field_is_child_of_multi_parm)||
        !hapi_get_int(env, tuple_record[30], &field_instance_num)||
        !hapi_get_int(env, tuple_record[31], &field_instance_length)||
        !hapi_get_int(env, tuple_record[32], &field_instance_count)||
        !hapi_get_int(env, tuple_record[33], &field_instance_start_offset)||
        !hapi_get_hapi_ramp_type(env, tuple_record[34], &field_ramp_type))
    {
        return false;
    }

    hapi_struct->id = field_id;
    hapi_struct->parentId = field_parent_id;
    hapi_struct->type = field_type;
    hapi_struct->typeInfoSH = field_type_info_sh;
    hapi_struct->permissions = field_permissions;
    hapi_struct->size = field_size;
    hapi_struct->choiceCount = field_choice_count;
    hapi_struct->nameSH = field_name_sh;
    hapi_struct->labelSH = field_label_sh;
    hapi_struct->templateNameSH = field_template_name_sh;
    hapi_struct->helpSH = field_help_sh;
    hapi_struct->hasMin = field_has_min;
    hapi_struct->hasMax = field_has_max;
    hapi_struct->hasUIMin = field_has_uimin;
    hapi_struct->hasUIMax = field_has_uimax;
    hapi_struct->min = field_min;
    hapi_struct->max = field_max;
    hapi_struct->UIMin = field_uimin;
    hapi_struct->UIMax = field_uimax;
    hapi_struct->invisible = field_invisible;
    hapi_struct->disabled = field_disabled;
    hapi_struct->spare = field_spare;
    hapi_struct->joinNext = field_join_next;
    hapi_struct->labelNone = field_label_none;
    hapi_struct->intValuesIndex = field_int_values_index;
    hapi_struct->floatValuesIndex = field_float_values_index;
    hapi_struct->stringValuesIndex = field_string_values_index;
    hapi_struct->choiceIndex = field_choice_index;
    hapi_struct->isChildOfMultiParm = field_is_child_of_multi_parm;
    hapi_struct->instanceNum = field_instance_num;
    hapi_struct->instanceLength = field_instance_length;
    hapi_struct->instanceCount = field_instance_count;
    hapi_struct->instanceStartOffset = field_instance_start_offset;
    hapi_struct->rampType = field_ramp_type;

    return true;
}


/* Converting array of HAPI_ParmInfo objects from c to erl. */
ERL_NIF_TERM
hapi_make_hapi_parm_info_list(ErlNifEnv* env, const HAPI_ParmInfo* hapi_structs, uint32_t list_size)
{
    ERL_NIF_TERM list = enif_make_list(env, 0);

    for(int32_t idx = list_size - 1; idx >= 0; idx--)
    {
        const HAPI_ParmInfo* hapi_struct = hapi_structs + idx;
        list = enif_make_list_cell(env, hapi_make_hapi_parm_info(env, hapi_struct), list);
    }

    return list;
}


/* Converting list of HAPI_ParmInfo objects from erl to c. */
bool
hapi_get_hapi_parm_info_list(ErlNifEnv* env, const ERL_NIF_TERM term, HAPI_ParmInfo* hapi_structs, uint32_t list_size)
{
    uint32_t read_list_size = 0;
    ERL_NIF_TERM head, tail;

    if(enif_get_list_length(env, term, &read_list_size) && (list_size == read_list_size))
    {
        ERL_NIF_TERM list = term;
        int32_t index = 0;

        while(enif_get_list_cell(env, list, &head, &tail))
        {
            HAPI_ParmInfo* hapi_struct = hapi_structs + index;

            if(!hapi_get_hapi_parm_info(env, head, hapi_struct))
            {
                return false;
            }

            index++;
            list = tail;
        }

        return true;
    }

    return false;
}

